<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è®°å¿†å¯è§†åŒ– - infinite-chat</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --bg-tertiary: #0f3460;
      --accent: #e94560;
      --accent-light: #ff6b6b;
      --text-primary: #eee;
      --text-secondary: #aaa;
      --text-muted: #666;
      --success: #4ade80;
      --warning: #fbbf24;
      --info: #60a5fa;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 20px;
    }
    
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .header h1 {
      color: var(--accent);
      font-size: 1.5em;
    }
    
    .back-btn {
      color: var(--text-secondary);
      text-decoration: none;
      padding: 8px 16px;
      border-radius: 8px;
      background: var(--bg-secondary);
      transition: all 0.2s;
    }
    
    .back-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }
    
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .tab-btn {
      padding: 10px 20px;
      background: var(--bg-secondary);
      border: none;
      color: var(--text-secondary);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .tab-btn:hover {
      background: var(--bg-tertiary);
    }
    
    .tab-btn.active {
      background: var(--accent);
      color: white;
    }
    
    .tab-panel {
      display: none;
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 20px;
      min-height: 500px;
    }
    
    .tab-panel.active {
      display: block;
    }
    
    /* ç»Ÿè®¡å¡ç‰‡ */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .stat-card {
      background: var(--bg-tertiary);
      border-radius: 10px;
      padding: 15px;
    }
    
    .stat-value {
      font-size: 2em;
      font-weight: bold;
      color: var(--accent);
    }
    
    .stat-label {
      color: var(--text-secondary);
      font-size: 0.9em;
      margin-top: 5px;
    }
    
    /* å›¾å½¢å®¹å™¨ */
    .chart-container {
      width: 100%;
      height: 400px;
      position: relative;
    }
    
    /* ç½‘ç»œå›¾ */
    #graph-canvas {
      width: 100%;
      height: 400px;
      background: var(--bg-primary);
      border-radius: 8px;
    }
    
    /* çƒ­åŠ›å›¾ */
    .heatmap {
      display: grid;
      grid-template-columns: 50px repeat(24, 1fr);
      gap: 2px;
    }
    
    .heatmap-label {
      font-size: 0.7em;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .heatmap-cell {
      aspect-ratio: 1;
      border-radius: 2px;
      background: var(--bg-tertiary);
      transition: all 0.2s;
    }
    
    .heatmap-cell:hover {
      transform: scale(1.2);
      z-index: 1;
    }
    
    /* æ—¶é—´çº¿ */
    .timeline {
      max-height: 500px;
      overflow-y: auto;
    }
    
    .timeline-item {
      display: flex;
      gap: 15px;
      padding: 15px 0;
      border-bottom: 1px solid var(--bg-tertiary);
    }
    
    .timeline-date {
      width: 100px;
      font-size: 0.9em;
      color: var(--accent);
      flex-shrink: 0;
    }
    
    .timeline-content {
      flex: 1;
    }
    
    .timeline-memories {
      margin-top: 10px;
    }
    
    .memory-tag {
      display: inline-block;
      padding: 4px 8px;
      margin: 2px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      font-size: 0.85em;
    }
    
    .memory-tag.preference { border-left: 3px solid var(--accent); }
    .memory-tag.fact { border-left: 3px solid var(--info); }
    .memory-tag.emotion { border-left: 3px solid var(--warning); }
    .memory-tag.event { border-left: 3px solid var(--success); }
    
    /* è¯äº‘ */
    .wordcloud {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      align-items: center;
      min-height: 300px;
    }
    
    .word-item {
      display: inline-block;
      padding: 5px 10px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .word-item:hover {
      background: var(--accent);
      transform: scale(1.1);
    }
    
    /* æœç´¢ */
    .search-box {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .search-box input {
      flex: 1;
      padding: 12px 16px;
      background: var(--bg-primary);
      border: 1px solid var(--bg-tertiary);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 1em;
    }
    
    .search-box input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .search-box button {
      padding: 12px 24px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
    }
    
    .search-results {
      margin-top: 20px;
    }
    
    .search-result {
      padding: 15px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      margin-bottom: 10px;
    }
    
    .search-result-content {
      margin-bottom: 8px;
    }
    
    .search-result-meta {
      font-size: 0.8em;
      color: var(--text-muted);
    }
    
    /* åŠ è½½åŠ¨ç”» */
    .loading {
      text-align: center;
      padding: 50px;
      color: var(--text-muted);
    }
    
    .loading::after {
      content: '...';
      animation: dots 1.5s infinite;
    }
    
    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }
    
    /* æ»šåŠ¨æ¡ */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: var(--bg-primary); }
    ::-webkit-scrollbar-thumb { background: var(--bg-tertiary); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent); }
  </style>
</head>
<body>
  <div class="header">
    <h1>ğŸ§  è®°å¿†å¯è§†åŒ–</h1>
    <a href="/" class="back-btn">â† è¿”å›èŠå¤©</a>
  </div>
  
  <div class="tabs">
    <button class="tab-btn active" data-tab="graph">çŸ¥è¯†å›¾è°±</button>
    <button class="tab-btn" data-tab="timeline">æ—¶é—´çº¿</button>
    <button class="tab-btn" data-tab="heatmap">æ´»è·ƒçƒ­åŠ›å›¾</button>
    <button class="tab-btn" data-tab="wordcloud">è¯äº‘</button>
    <button class="tab-btn" data-tab="search">æœç´¢</button>
  </div>
  
  <!-- ç»Ÿè®¡å¡ç‰‡ -->
  <div class="stats-grid" id="stats">
    <div class="stat-card">
      <div class="stat-value" id="totalMemories">-</div>
      <div class="stat-label">æ€»è®°å¿†æ•°</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="avgImportance">-</div>
      <div class="stat-label">å¹³å‡é‡è¦æ€§</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="oldestMemory">-</div>
      <div class="stat-label">æœ€æ—©è®°å¿†</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="newestMemory">-</div>
      <div class="stat-label">æœ€æ–°è®°å¿†</div>
    </div>
  </div>
  
  <!-- çŸ¥è¯†å›¾è°± -->
  <div class="tab-panel active" id="graph-panel">
    <canvas id="graph-canvas"></canvas>
  </div>
  
  <!-- æ—¶é—´çº¿ -->
  <div class="tab-panel" id="timeline-panel">
    <div class="timeline" id="timeline"></div>
  </div>
  
  <!-- çƒ­åŠ›å›¾ -->
  <div class="tab-panel" id="heatmap-panel">
    <div class="heatmap" id="heatmap"></div>
  </div>
  
  <!-- è¯äº‘ -->
  <div class="tab-panel" id="wordcloud-panel">
    <div class="wordcloud" id="wordcloud"></div>
  </div>
  
  <!-- æœç´¢ -->
  <div class="tab-panel" id="search-panel">
    <div class="search-box">
      <input type="text" id="searchInput" placeholder="æœç´¢è®°å¿†...">
      <button onclick="searchMemories()">æœç´¢</button>
    </div>
    <div class="search-results" id="searchResults"></div>
  </div>

  <script>
    // æ ‡ç­¾é¡µåˆ‡æ¢
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(btn.dataset.tab + '-panel').classList.add('active');
      });
    });

    // åŠ è½½è®°å¿†æ•°æ®
    async function loadMemoryGraph() {
      try {
        const res = await fetch('/api/memory/graph');
        const data = await res.json();
        
        updateStats(data.stats);
        drawGraph(data.nodes, data.edges);
      } catch (e) {
        console.error('Failed to load memory graph:', e);
      }
    }

    // æ›´æ–°ç»Ÿè®¡
    function updateStats(stats) {
      document.getElementById('totalMemories').textContent = stats.totalMemories;
      document.getElementById('avgImportance').textContent = (stats.avgImportance * 100).toFixed(0) + '%';
      
      if (stats.oldestMemory > 0) {
        document.getElementById('oldestMemory').textContent = new Date(stats.oldestMemory).toLocaleDateString();
      }
      if (stats.newestMemory > 0) {
        document.getElementById('newestMemory').textContent = new Date(stats.newestMemory).toLocaleDateString();
      }
    }

    // ç»˜åˆ¶çŸ¥è¯†å›¾è°±
    function drawGraph(nodes, edges) {
      const canvas = document.getElementById('graph-canvas');
      const ctx = canvas.getContext('2d');
      
      // è®¾ç½®ç”»å¸ƒå¤§å°
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      
      if (nodes.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('æš‚æ— è®°å¿†æ•°æ®', canvas.width / 2, canvas.height / 2);
        return;
      }
      
      // è®¡ç®—èŠ‚ç‚¹ä½ç½®ï¼ˆç®€å•çš„åœ†å½¢å¸ƒå±€ï¼‰
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(centerX, centerY) - 50;
      
      nodes.forEach((node, i) => {
        const angle = (2 * Math.PI * i) / nodes.length;
        node.x = centerX + radius * Math.cos(angle);
        node.y = centerY + radius * Math.sin(angle);
      });
      
      // ç»˜åˆ¶è¾¹
      ctx.strokeStyle = 'rgba(233, 69, 96, 0.3)';
      ctx.lineWidth = 1;
      
      edges.forEach(edge => {
        const source = nodes.find(n => n.id === edge.source);
        const target = nodes.find(n => n.id === edge.target);
        
        if (source && target) {
          ctx.beginPath();
          ctx.moveTo(source.x, source.y);
          ctx.lineTo(target.x, target.y);
          ctx.stroke();
        }
      });
      
      // ç»˜åˆ¶èŠ‚ç‚¹
      const colors = {
        preference: '#e94560',
        fact: '#60a5fa',
        emotion: '#fbbf24',
        event: '#4ade80',
        user: '#888',
      };
      
      nodes.forEach(node => {
        const size = 5 + node.importance * 15;
        
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, 2 * Math.PI);
        ctx.fillStyle = colors[node.type] || '#888';
        ctx.fill();
        
        // ç»˜åˆ¶æ ‡ç­¾
        ctx.fillStyle = '#eee';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        const label = node.content.slice(0, 10) + (node.content.length > 10 ? '...' : '');
        ctx.fillText(label, node.x, node.y + size + 12);
      });
      
      // ç»˜åˆ¶å›¾ä¾‹
      const legendY = 20;
      let legendX = 20;
      
      Object.entries(colors).forEach(([type, color]) => {
        ctx.beginPath();
        ctx.arc(legendX, legendY, 6, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.fill();
        
        ctx.fillStyle = '#aaa';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(type, legendX + 10, legendY + 4);
        
        legendX += 80;
      });
    }

    // åŠ è½½æ—¶é—´çº¿
    async function loadTimeline() {
      try {
        const res = await fetch('/api/memory/timeline');
        const data = await res.json();
        
        const container = document.getElementById('timeline');
        container.innerHTML = '';
        
        if (data.timeline.length === 0) {
          container.innerHTML = '<div class="loading">æš‚æ— æ—¶é—´çº¿æ•°æ®</div>';
          return;
        }
        
        data.timeline.reverse().forEach(item => {
          const div = document.createElement('div');
          div.className = 'timeline-item';
          
          const memoriesHtml = item.memories.map(m => 
            `<span class="memory-tag ${m.type}">${m.content.slice(0, 30)}${m.content.length > 30 ? '...' : ''}</span>`
          ).join('');
          
          div.innerHTML = `
            <div class="timeline-date">${item.date}</div>
            <div class="timeline-content">
              <div>${item.count} æ¡è®°å¿†</div>
              <div class="timeline-memories">${memoriesHtml}</div>
            </div>
          `;
          
          container.appendChild(div);
        });
      } catch (e) {
        console.error('Failed to load timeline:', e);
      }
    }

    // åŠ è½½çƒ­åŠ›å›¾
    async function loadHeatmap() {
      try {
        const res = await fetch('/api/memory/heatmap');
        const data = await res.json();
        
        const container = document.getElementById('heatmap');
        container.innerHTML = '';
        
        const days = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
        
        // æ·»åŠ è¡¨å¤´ï¼ˆå°æ—¶ï¼‰
        container.appendChild(document.createElement('div')); // ç©ºç™½
        for (let h = 0; h < 24; h++) {
          const label = document.createElement('div');
          label.className = 'heatmap-label';
          label.textContent = h;
          container.appendChild(label);
        }
        
        // æ·»åŠ æ•°æ®
        const maxCount = Math.max(...data.heatmap.map(d => d.count), 1);
        
        for (let day = 0; day < 7; day++) {
          // æ˜ŸæœŸæ ‡ç­¾
          const dayLabel = document.createElement('div');
          dayLabel.className = 'heatmap-label';
          dayLabel.textContent = days[day];
          container.appendChild(dayLabel);
          
          // æ¯å°æ—¶æ•°æ®
          for (let hour = 0; hour < 24; hour++) {
            const item = data.heatmap.find(d => d.hour === hour && d.day === day);
            const cell = document.createElement('div');
            cell.className = 'heatmap-cell';
            
            if (item && item.count > 0) {
              const intensity = item.count / maxCount;
              const r = Math.round(233 * intensity);
              const g = Math.round(69 * intensity);
              const b = Math.round(96 * intensity);
              cell.style.background = `rgb(${r}, ${g}, ${b})`;
              cell.title = `${item.count} æ¡è®°å¿†`;
            }
            
            container.appendChild(cell);
          }
        }
      } catch (e) {
        console.error('Failed to load heatmap:', e);
      }
    }

    // åŠ è½½è¯äº‘
    async function loadWordCloud() {
      try {
        const res = await fetch('/api/memory/wordcloud');
        const data = await res.json();
        
        const container = document.getElementById('wordcloud');
        container.innerHTML = '';
        
        if (data.wordcloud.length === 0) {
          container.innerHTML = '<div class="loading">æš‚æ— è¯äº‘æ•°æ®</div>';
          return;
        }
        
        const maxCount = data.wordcloud[0].count;
        
        data.wordcloud.forEach(word => {
          const span = document.createElement('span');
          span.className = 'word-item';
          span.textContent = word.word;
          
          const size = 12 + (word.count / maxCount) * 20;
          span.style.fontSize = size + 'px';
          span.style.opacity = 0.5 + word.importance * 0.5;
          
          span.title = `å‡ºç° ${word.count} æ¬¡`;
          
          container.appendChild(span);
        });
      } catch (e) {
        console.error('Failed to load wordcloud:', e);
      }
    }

    // æœç´¢è®°å¿†
    async function searchMemories() {
      const query = document.getElementById('searchInput').value.trim();
      
      if (!query) return;
      
      try {
        const res = await fetch(`/api/memory/search?q=${encodeURIComponent(query)}`);
        const data = await res.json();
        
        const container = document.getElementById('searchResults');
        container.innerHTML = '';
        
        if (data.results.length === 0) {
          container.innerHTML = '<div class="loading">æœªæ‰¾åˆ°ç›¸å…³è®°å¿†</div>';
          return;
        }
        
        data.results.forEach(result => {
          const div = document.createElement('div');
          div.className = 'search-result';
          
          div.innerHTML = `
            <div class="search-result-content">${result.content}</div>
            <div class="search-result-meta">
              ç±»å‹: ${result.type} | 
              é‡è¦æ€§: ${(result.importance * 100).toFixed(0)}% |
              åˆ›å»º: ${new Date(result.createdAt).toLocaleDateString()}
            </div>
          `;
          
          container.appendChild(div);
        });
      } catch (e) {
        console.error('Failed to search:', e);
      }
    }

    // æœç´¢æ¡†å›è½¦
    document.getElementById('searchInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') searchMemories();
    });

    // åˆå§‹åŒ–
    loadMemoryGraph();
    loadTimeline();
    loadHeatmap();
    loadWordCloud();

    // çª—å£å¤§å°æ”¹å˜æ—¶é‡ç»˜å›¾è°±
    window.addEventListener('resize', () => {
      loadMemoryGraph();
    });
  </script>
</body>
</html>
